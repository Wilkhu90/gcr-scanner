package io.jenkins.plugins.gcr_scanner;

import com.google.gson.Gson;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import dnl.utils.text.table.TextTable;
import hudson.*;
import hudson.model.*;
import hudson.slaves.SlaveComputer;
import hudson.tasks.BuildStepDescriptor;
import hudson.tasks.Builder;
import hudson.util.FormValidation;
import io.grafeas.v1.Occurrence;
import io.grafeas.v1.Severity;
import io.grafeas.v1.VulnerabilityOccurrence;
import jenkins.model.Jenkins;
import jenkins.tasks.SimpleBuildStep;
import org.jenkinsci.Symbol;
import org.kohsuke.stapler.DataBoundConstructor;
import org.kohsuke.stapler.DataBoundSetter;
import org.kohsuke.stapler.QueryParameter;
import javax.annotation.Nonnull;
import javax.servlet.ServletException;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

public class GcrVulnerabilityBuilder extends Builder implements SimpleBuildStep {

    private String imageName;

    @DataBoundConstructor
    public GcrVulnerabilityBuilder(String imageName) {
        this.imageName = imageName;
    }

    public String getImageName() {
        return imageName;
    }

    @DataBoundSetter
    public void setImageName(String imageName) {
        this.imageName = imageName;
    }

    public static DescriptorImpl descriptor() {
        final Jenkins jenkins = Jenkins.getInstance();
        if (jenkins == null) {
            throw new IllegalStateException("Jenkins instance is not ready");
        }
        return jenkins.getDescriptorByType(GcrVulnerabilityBuilder.DescriptorImpl.class);
    }

    @Override
    public void perform(@Nonnull Run<?, ?> run, @Nonnull FilePath filePath, @Nonnull Launcher launcher, @Nonnull TaskListener taskListener) throws InterruptedException, IOException {
        taskListener.getLogger().printf("GCR Image Scanning for %s in progress...\n", imageName);
        String[] imageTokens = imageName.split("/");
        if(imageTokens.length >= 3 && imageTokens[0].contains("gcr.io") && imageTokens[imageTokens.length-1].contains("sha256")) {
            String projectName = imageTokens[1];
            String resourceUrl = "https://"+imageName;
            taskListener.getLogger().println("ProjectName is " + projectName);
            taskListener.getLogger().println("ResourceUrl is " + resourceUrl);
            GcrVulnerabilityScanner scanner = new GcrVulnerabilityScanner();
            ArrayList<Occurrence> scanOutput = scanner.run(resourceUrl, projectName, taskListener, launcher);
            if(scanOutput.size() > 0) {
                taskListener.getLogger().println("The total vulnerabilities are " + scanOutput.size());
                generateTable(scanOutput, taskListener);
                FilePath opaFile = new FilePath(filePath, "opa");
                FilePath opaRegoFile = new FilePath(filePath, "basic-policy.rego");
                EnvVars envVars = run.getEnvironment(taskListener);
                FilePath masterOpaFile = new FilePath(SlaveComputer.getChannelToMaster(), envVars.get("JENKINS_HOME", "/var/jenkins_home")+"/plugins/gcr_scanner/opa");
                opaFile.copyFrom(masterOpaFile);
                opaRegoFile.write(GcrVulnerabilityBuilder.descriptor().getOpaRegoPolicy(), "UTF-8");
                opaFile.chmod(0777);
                String inputString = getOpaInputForEvaluation(scanOutput, taskListener, launcher);
                FilePath opaFileJsonInput = new FilePath(filePath, "input.json");
                opaFileJsonInput.write(inputString, "UTF-8");

                boolean deny_image = executeOpaCommand("data.gcr_scanner.deny_image", opaFile, opaRegoFile, opaFileJsonInput, launcher, taskListener);
                boolean allow_image = executeOpaCommand("data.gcr_scanner.allow_image", opaFile, opaRegoFile, opaFileJsonInput, launcher, taskListener);
                boolean allow_image_with_warnings = executeOpaCommand("data.gcr_scanner.allow_image_with_warnings", opaFile, opaRegoFile, opaFileJsonInput, launcher, taskListener);
                taskListener.getLogger().printf("The status of OPA commands are allow_image: %s, deny_image:%s, allow_image_with_warnings:%s\n", allow_image?"true":"false", deny_image?"true":"false", allow_image_with_warnings?"true":"false");
                if(deny_image) {
                    taskListener.fatalError("The Image is denied as it doesn't satisfies the policy.");
                } else if(allow_image_with_warnings) {
                    taskListener.error("[WARNING]: The Image is allowed but needs a few fixes based on the policy.");
                } else if(allow_image) {
                    taskListener.getLogger().println("The image looks clean and good to go based the policy.");
                } else {
                    taskListener.error("The Image is denied as it doesn't satisfies the policy.");
                }
            }
        } else {
            taskListener.error("The GCR image is invalid. Please specify gcr image only.");
        }
    }

    public boolean executeOpaCommand(String filter, FilePath opaFile, FilePath opaRegoFile, FilePath opaFileJsonInput, Launcher launcher, TaskListener taskListener) throws IOException, InterruptedException {
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        ByteArrayOutputStream err = new ByteArrayOutputStream();
        StringBuffer str = new StringBuffer();
        str.append(opaFile.getRemote());
        str.append(" eval -d ");
        str.append(opaRegoFile.getRemote());
        str.append(" -i ");
        str.append(opaFileJsonInput.getRemote());
        str.append(" '");
        str.append(filter);
        str.append("'");

        int status = launcher.launch()
                .cmdAsSingleString(str.toString())
                .stdout(out)
                .stderr(err).quiet(true).join();
        if(status == 0) {
            return opaEvalStatus(out.toString());
        }
        return false;
    }

    public boolean opaEvalStatus(String opaOutput) {
        JsonElement jsonElement = JsonParser.parseString(opaOutput);
        JsonObject object = jsonElement.getAsJsonObject();
        if(object.has("result")) {
            JsonElement result = object.get("result");
            return result.getAsJsonArray().get(0).getAsJsonObject().get("expressions").getAsJsonArray().get(0).getAsJsonObject().get("value").getAsBoolean();
        } else {
            return false;
        }
    }

    public String getOpaInputForEvaluation(ArrayList<Occurrence> scanOutput, TaskListener taskListener, Launcher launcher) {
        Gson gson = new Gson();
        ArrayList<ScanOutput> scanOutputArrayList = new ArrayList<>();
        for(int i=0; i<scanOutput.size(); i++) {
            Occurrence currentOccurrence = scanOutput.get(i);
            List<VulnerabilityOccurrence.PackageIssue> packageIssueList = currentOccurrence.getVulnerability().getPackageIssueList();
            StringBuffer packages = new StringBuffer();
            StringBuffer versions = new StringBuffer();
            StringBuffer statuses = new StringBuffer();
            String[] noteTokens = currentOccurrence.getNoteName().split("/");
            for(VulnerabilityOccurrence.PackageIssue issue : packageIssueList) {
                packages.append(issue.getAffectedPackage());
                versions.append(issue.getAffectedVersion().getFullName());
                if(issue.getFixAvailable()) {
                    statuses.append("Fixed in ");
                    statuses.append(issue.getFixedVersion().getFullName());
                } else {
                    statuses.append("No Fix available");
                }
                ScanOutput currentInput = new ScanOutput(
                        noteTokens[noteTokens.length - 1],
                        packages.toString(),
                        versions.toString(),
                        Severity.forNumber(currentOccurrence.getVulnerability().getSeverity().getNumber()).toString(),
                        statuses.toString());
                scanOutputArrayList.add(currentInput);
            }
        }
        String finalInput = "{ \"result\": "+gson.toJson(scanOutputArrayList)+" }";
        return finalInput;
    }

    public void generateTable(ArrayList<Occurrence> scanOutput, TaskListener taskListener) {
        String[] columnNames = {
                "CVE",
                "Package",
                "Version",
                "Severity",
                "Status"
        };
        Object[][] dataTable = new Object[scanOutput.size()][columnNames.length];
        for(int i=0; i<scanOutput.size(); i++) {
            Occurrence currentOccurrence = scanOutput.get(i);
            List<VulnerabilityOccurrence.PackageIssue> packageIssueList = currentOccurrence.getVulnerability().getPackageIssueList();
            StringBuffer packages = new StringBuffer();
            StringBuffer versions = new StringBuffer();
            StringBuffer statuses = new StringBuffer();
            String[] noteTokens = currentOccurrence.getNoteName().split("/");
            for(VulnerabilityOccurrence.PackageIssue issue : packageIssueList) {
                packages.append(issue.getAffectedPackage());
                versions.append(issue.getAffectedVersion().getFullName());
                if(issue.getFixAvailable()) {
                    statuses.append("Fixed in ");
                    statuses.append(issue.getFixedVersion().getFullName());
                } else {
                    statuses.append("No Fix available");
                }
                dataTable[i] = new Object[] {
                        noteTokens[noteTokens.length - 1],
                        packages.toString(),
                        versions.toString(),
                        Severity.forNumber(currentOccurrence.getVulnerability().getSeverity().getNumber()),
                        statuses.toString()
                };
            }
        }
        TextTable textTable = new TextTable(columnNames, dataTable);
        textTable.setAddRowNumbering(true);
        textTable.printTable(taskListener.getLogger(), 0);
    }

    @Symbol("gcrImageVulnerabilityScanner")
    @Extension
    public static final class DescriptorImpl extends BuildStepDescriptor<Builder> {
        private String opaRegoPolicy = "package gcr_scanner\n" +
                "\n" +
                "test_severity(input_severity, expected_severity) {\n" +
                "    input_severity == expected_severity\n" +
                "}\n" +
                "\n" +
                "deny_image {\n" +
                "    test_severity(input.result[_].Severity, \"CRITICAL\")\n" +
                "}\n" +
                "\n" +
                "deny_image {\n" +
                "    test_severity(input.result[_].Severity, \"HIGH\")\n" +
                "}\n" +
                "\n" +
                "allow_image_with_warnings {\n" +
                "    startswith(input.result[_].Status, \"Fixed\")\n" +
                "    not deny_image\n" +
                "}\n" +
                "\n" +
                "allow_image {\n" +
                "    not deny_image\n" +
                "    not allow_image_with_warnings\n" +
                "}";

        public String getOpaRegoPolicy() {
            return opaRegoPolicy;
        }

        @DataBoundSetter
        public void setOpaRegoPolicy(String opaRegoPolicy) {
            if(opaRegoPolicy != null && !opaRegoPolicy.isEmpty()) {
                this.opaRegoPolicy = opaRegoPolicy;
            }
            save();
        }

        public FormValidation doCheckImageName(@QueryParameter String value) throws IOException, ServletException {
            String[] imageTokens = value.split("/");
            if(imageTokens.length >= 3 && imageTokens[0].contains("gcr.io")) {
                if(imageTokens[imageTokens.length-1].contains("sha256")) {
                    return FormValidation.ok();
                } else {
                    return FormValidation.error("Please specify gcr image with SHA256 digest. Tags not allowed.");
                }
            } else {
                return FormValidation.error("Please specify gcr image only.");
            }
        }

        @Override
        public boolean isApplicable(Class<? extends AbstractProject> aClass) {
            return true;
        }

        @Override
        public String getDisplayName() {
            return "GCR Image Vulnerability Scanner";
        }

    }
}
