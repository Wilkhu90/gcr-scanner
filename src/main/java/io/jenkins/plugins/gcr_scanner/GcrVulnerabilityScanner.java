package io.jenkins.plugins.gcr_scanner;

import com.google.api.gax.core.FixedCredentialsProvider;
import com.google.auth.oauth2.GoogleCredentials;
import com.google.cloud.devtools.containeranalysis.v1.ContainerAnalysisClient;
import com.google.cloud.devtools.containeranalysis.v1.ContainerAnalysisSettings;
import hudson.Launcher;
import hudson.model.TaskListener;
import io.grafeas.v1.GrafeasClient;
import io.grafeas.v1.Occurrence;
import io.grafeas.v1.ProjectName;
import java.io.IOException;
import java.util.ArrayList;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import io.grafeas.v1.DiscoveryOccurrence.AnalysisStatus;

public class GcrVulnerabilityScanner {

    public ArrayList<Occurrence> run(String resourceUrl, String projectId, TaskListener taskListener, Launcher launcher) {
        try {
            taskListener.getLogger().println("Creating GrafeasClient now...");
            GoogleCredentials credentials = GoogleCredentials.getApplicationDefault();
            ContainerAnalysisSettings settings = ContainerAnalysisSettings.newBuilder()
                    .setCredentialsProvider(FixedCredentialsProvider.create(credentials))
                    .build();
            GrafeasClient client = ContainerAnalysisClient
                    .create(settings)
                    .getGrafeasClient();
            taskListener.getLogger().println("Created GrafeasClient...");

            pollDiscoveryOccurrenceFinished(client, resourceUrl, projectId, 5);

            final String projectName = ProjectName.format(projectId);
            String filterStr = String.format("kind=\"VULNERABILITY\" AND resourceUrl=\"%s\"", resourceUrl);
            ArrayList<Occurrence> vulnerabilitylist = new ArrayList<>();
            taskListener.getLogger().println("Creating request for list occurrences...");
            GrafeasClient.ListOccurrencesPagedResponse response = client.listOccurrences(projectName, filterStr);
            taskListener.getLogger().println("List occurrences API call responded...");
            for (Occurrence o : response.iterateAll()) {
                vulnerabilitylist.add(o);
            }
            client.close();
            return vulnerabilitylist;
        } catch (Exception ex) {
            taskListener.error(ex.getLocalizedMessage());
        }
        taskListener.getLogger().println("Something went wrong while setting up GrafeasClient...");
        return new ArrayList<>();
    }
    public static Occurrence pollDiscoveryOccurrenceFinished(GrafeasClient client, String resourceUrl, String projectId, long timeoutSeconds) throws IOException, TimeoutException, InterruptedException {
        final String projectName = ProjectName.format(projectId);
        long deadline = System.currentTimeMillis() + timeoutSeconds * 1000;

        // find the discovery occurrence using a filter string
        Occurrence discoveryOccurrence = null;
        // vulbnerability discovery occurrences are always associated with the
        // PACKAGE_VULNERABILITY note in the "goog-analysis" GCP project
        String filter =  String.format("resourceUrl=\"%s\" AND noteProjectId=\"%s\" AND noteId=\"%s\"",
                resourceUrl, "goog-analysis",  "PACKAGE_VULNERABILITY");
        while (discoveryOccurrence == null) {
            for (Occurrence o : client.listOccurrences(projectName, filter).iterateAll()) {
                if (o.getDiscovery() != null) {
                    // there should be only one valid discovery occurrence returned by the given filter
                    discoveryOccurrence = o;
                }
            }
            TimeUnit.SECONDS.sleep(1);
            // check for timeout
            if (System.currentTimeMillis() > deadline) {
                throw new TimeoutException("discovery occurrence not found");
            }
        }

        // wait for discovery occurrence to enter a terminal state
        AnalysisStatus status = AnalysisStatus.PENDING;
        while (status != AnalysisStatus.FINISHED_SUCCESS
                && status != AnalysisStatus.FINISHED_FAILED
                && status != AnalysisStatus.FINISHED_UNSUPPORTED) {
            // update the occurrence state
            discoveryOccurrence = client.getOccurrence(discoveryOccurrence.getName());
            status = discoveryOccurrence.getDiscovery().getAnalysisStatus();
            TimeUnit.SECONDS.sleep(1);
            // check for timeout
            if (System.currentTimeMillis() > deadline) {
                throw new TimeoutException("discovery occurrence not in terminal state");
            }
        }
        return discoveryOccurrence;
    }
}
